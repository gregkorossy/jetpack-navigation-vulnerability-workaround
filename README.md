# Jetpack Navigation vulnerability workaround

Some time ago an [article](https://swarm.ptsecurity.com/android-jetpack-navigation-go-even-deeper/)
showed the world how an attacker may exploit implicit deep links in the Jetpack Navigation library.
While the article goes deep on the problem, it lacks a workaround for mitigating a _possible_
vulnerability that Google doesn't mind fixing since they think it _works as intended_.

## The issue

Consider the following example in your super secure application:

```kotlin
NavHost(
    modifier = modifier,
    navController = navController,
    startDestination = "home"
) {
    composable("home") {
        HomeScreen(
            modifier = Modifier.fillMaxSize(),
            onLoggedIn = {
                navController.navigate("private")
            }
        )
    }

    composable("private") {
        PrivateScreen(
            modifier = Modifier.fillMaxSize()
        )
    }
}
```

Here if the user opens the application, they are met with the "home" screen which acts as the gatekeeper for
the "private" screen.

The way the Jetpack Navigation library works is that internally an _implicit deep link_ is created for
every destination in the form of `android-app://androidx.navigation/$route`. This is used internally
by the library to navigate to screens when `navController.navigate("...")` is called.

The problem is that since this is a deep link, it can be accessed from outside the app. If an attacker
knows a little about the target application (_e.g. the package name, the Activity name, the screen
route it wants to navigate to_), they might be able to circumvent the protection provided by the
gatekeeper screen.

```kotlin
Intent().apply {
    setClassName(
        "me.gingerninja.dev.navfix.target",
        "me.gingerninja.dev.navfix.target.MainActivity"
    )
    data = Uri.parse("android-app://androidx.navigation/private")

    startActivity(this)
}
```

Calling the above code would open the target app's "private" screen without showing the "home" one,
effectively eliminating the security.

## The workaround

There are two possible solutions (other than using a different navigation library):

1. Implement the Google-recommended [conditional navigation](https://developer.android.com/guide/navigation/navigation-conditional)
2. Use a workaround that eliminates the possible attack.

We are going with number 2, just to show an alternative. Since we know that the attacker must use a
specific URI to access the screens, we can basically filter out this from the incoming `Intent` of
our app.

First, introduce an extension function for the `Intent` that will remove the `data` set when it
encounters a navigation link:

```kotlin
fun Intent.withoutNavData(): Intent {
    val attacking = data?.run {
        // these are hardcoded values in NavDestination
        scheme == "android-app" && host == "androidx.navigation"
    } ?: false

    return if (attacking) {
        Intent(this).setData(null)
    } else {
        this
    }
}
```

Then, call this function in the `Activity.onCreate(...)` _before_ the `setContent { ... }` call and
set the intent of the Activity to the returned value:

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        // we set the new intent which should not have the deep link anymore
        intent = intent.withoutNavData()

        super.onCreate(savedInstanceState)

        // [...] other calls
    }
}
```

If you use a `launchMode` in your manifest other than the default one, you might need to override the
`onNewIntent(...)` function as well (see [handling deep links](https://developer.android.com/guide/navigation/design/deep-link#handle) for more details):

```kotlin
override fun onNewIntent(intent: Intent) {
    val cleanIntent = intent.withoutNavData()
    super.onNewIntent(cleanIntent)
    navController.handleDeepLink(cleanIntent)
}
```

That's it! Now if the attacker tries to access your private screens with the aforementioned attack,
the deep link data will be removed from the intent before the `NavController` could handle it.